//Do not edit! This file was generated by Unity-ROS MessageGeneration.
using System;
using System.Linq;
using System.Collections.Generic;
using System.Text;
using Unity.Robotics.ROSTCPConnector.MessageGeneration;

namespace RosMessageTypes.Moveit
{
    public class PickupGoal : Message
    {
        public const string RosMessageName = "moveit_msgs/Pickup";

        //  An action for picking up an object
        //  The name of the object to pick up (as known in the planning scene)
        public string target_name;
        //  which group should be used to plan for pickup
        public string group_name;
        //  which end-effector to be used for pickup (ideally descending from the group above)
        public string end_effector;
        //  a list of possible grasps to be used. At least one grasp must be filled in
        public Grasp[] possible_grasps;
        //  the name that the support surface (e.g. table) has in the collision map
        //  can be left empty if no name is available
        public string support_surface_name;
        //  whether collisions between the gripper and the support surface should be acceptable
        //  during move from pre-grasp to grasp and during lift. Collisions when moving to the
        //  pre-grasp location are still not allowed even if this is set to true.
        public bool allow_gripper_support_collision;
        //  The names of the links the object to be attached is allowed to touch;
        //  If this is left empty, it defaults to the links in the used end-effector
        public string[] attached_object_touch_links;
        //  Optionally notify the pick action that it should approach the object further,
        //  as much as possible (this minimizing the distance to the object before the grasp)
        //  along the approach direction; Note: this option changes the grasping poses
        //  supplied in possible_grasps[] such that they are closer to the object when possible.
        public bool minimize_object_distance;
        //  Optional constraints to be imposed on every point in the motion plan
        public Constraints path_constraints;
        //  The name of the motion planner to use. If no name is specified,
        //  a default motion planner will be used
        public string planner_id;
        //  an optional list of obstacles that we have semantic information about
        //  and that can be touched/pushed/moved in the course of grasping;
        //  CAREFUL: If the object name 'all' is used, collisions with all objects are disabled during the approach & lift.
        public string[] allowed_touch_objects;
        //  The maximum amount of time the motion planner is allowed to plan for
        public double allowed_planning_time;
        //  Planning options
        public PlanningOptions planning_options;

        public PickupGoal()
        {
            this.target_name = "";
            this.group_name = "";
            this.end_effector = "";
            this.possible_grasps = new Grasp[0];
            this.support_surface_name = "";
            this.allow_gripper_support_collision = false;
            this.attached_object_touch_links = new string[0];
            this.minimize_object_distance = false;
            this.path_constraints = new Constraints();
            this.planner_id = "";
            this.allowed_touch_objects = new string[0];
            this.allowed_planning_time = 0.0;
            this.planning_options = new PlanningOptions();
        }

        public PickupGoal(string target_name, string group_name, string end_effector, Grasp[] possible_grasps, string support_surface_name, bool allow_gripper_support_collision, string[] attached_object_touch_links, bool minimize_object_distance, Constraints path_constraints, string planner_id, string[] allowed_touch_objects, double allowed_planning_time, PlanningOptions planning_options)
        {
            this.target_name = target_name;
            this.group_name = group_name;
            this.end_effector = end_effector;
            this.possible_grasps = possible_grasps;
            this.support_surface_name = support_surface_name;
            this.allow_gripper_support_collision = allow_gripper_support_collision;
            this.attached_object_touch_links = attached_object_touch_links;
            this.minimize_object_distance = minimize_object_distance;
            this.path_constraints = path_constraints;
            this.planner_id = planner_id;
            this.allowed_touch_objects = allowed_touch_objects;
            this.allowed_planning_time = allowed_planning_time;
            this.planning_options = planning_options;
        }
        public override List<byte[]> SerializationStatements()
        {
            var listOfSerializations = new List<byte[]>();
            listOfSerializations.Add(SerializeString(this.target_name));
            listOfSerializations.Add(SerializeString(this.group_name));
            listOfSerializations.Add(SerializeString(this.end_effector));
            
            listOfSerializations.Add(BitConverter.GetBytes(possible_grasps.Length));
            foreach(var entry in possible_grasps)
                listOfSerializations.Add(entry.Serialize());
            listOfSerializations.Add(SerializeString(this.support_surface_name));
            listOfSerializations.Add(BitConverter.GetBytes(this.allow_gripper_support_collision));
            
            listOfSerializations.Add(BitConverter.GetBytes(attached_object_touch_links.Length));
            foreach(var entry in attached_object_touch_links)
                listOfSerializations.Add(SerializeString(entry));
            listOfSerializations.Add(BitConverter.GetBytes(this.minimize_object_distance));
            listOfSerializations.AddRange(path_constraints.SerializationStatements());
            listOfSerializations.Add(SerializeString(this.planner_id));
            
            listOfSerializations.Add(BitConverter.GetBytes(allowed_touch_objects.Length));
            foreach(var entry in allowed_touch_objects)
                listOfSerializations.Add(SerializeString(entry));
            listOfSerializations.Add(BitConverter.GetBytes(this.allowed_planning_time));
            listOfSerializations.AddRange(planning_options.SerializationStatements());

            return listOfSerializations;
        }

        public override int Deserialize(byte[] data, int offset)
        {
            var target_nameStringBytesLength = DeserializeLength(data, offset);
            offset += 4;
            this.target_name = DeserializeString(data, offset, target_nameStringBytesLength);
            offset += target_nameStringBytesLength;
            var group_nameStringBytesLength = DeserializeLength(data, offset);
            offset += 4;
            this.group_name = DeserializeString(data, offset, group_nameStringBytesLength);
            offset += group_nameStringBytesLength;
            var end_effectorStringBytesLength = DeserializeLength(data, offset);
            offset += 4;
            this.end_effector = DeserializeString(data, offset, end_effectorStringBytesLength);
            offset += end_effectorStringBytesLength;
            
            var possible_graspsArrayLength = DeserializeLength(data, offset);
            offset += 4;
            this.possible_grasps= new Grasp[possible_graspsArrayLength];
            for(var i = 0; i < possible_graspsArrayLength; i++)
            {
                this.possible_grasps[i] = new Grasp();
                offset = this.possible_grasps[i].Deserialize(data, offset);
            }
            var support_surface_nameStringBytesLength = DeserializeLength(data, offset);
            offset += 4;
            this.support_surface_name = DeserializeString(data, offset, support_surface_nameStringBytesLength);
            offset += support_surface_nameStringBytesLength;
            this.allow_gripper_support_collision = BitConverter.ToBoolean(data, offset);
            offset += 1;
            
            var attached_object_touch_linksArrayLength = DeserializeLength(data, offset);
            offset += 4;
            this.attached_object_touch_links= new string[attached_object_touch_linksArrayLength];
            for(var i = 0; i < attached_object_touch_linksArrayLength; i++)
            {
                var attached_object_touch_linksStringBytesLength = DeserializeLength(data, offset);
                offset += 4;
                this.attached_object_touch_links[i] = DeserializeString(data, offset, attached_object_touch_linksStringBytesLength);
                offset += attached_object_touch_linksStringBytesLength;
            }
            this.minimize_object_distance = BitConverter.ToBoolean(data, offset);
            offset += 1;
            offset = this.path_constraints.Deserialize(data, offset);
            var planner_idStringBytesLength = DeserializeLength(data, offset);
            offset += 4;
            this.planner_id = DeserializeString(data, offset, planner_idStringBytesLength);
            offset += planner_idStringBytesLength;
            
            var allowed_touch_objectsArrayLength = DeserializeLength(data, offset);
            offset += 4;
            this.allowed_touch_objects= new string[allowed_touch_objectsArrayLength];
            for(var i = 0; i < allowed_touch_objectsArrayLength; i++)
            {
                var allowed_touch_objectsStringBytesLength = DeserializeLength(data, offset);
                offset += 4;
                this.allowed_touch_objects[i] = DeserializeString(data, offset, allowed_touch_objectsStringBytesLength);
                offset += allowed_touch_objectsStringBytesLength;
            }
            this.allowed_planning_time = BitConverter.ToDouble(data, offset);
            offset += 8;
            offset = this.planning_options.Deserialize(data, offset);

            return offset;
        }

        public override string ToString()
        {
            return "PickupGoal: " +
            "\ntarget_name: " + target_name.ToString() +
            "\ngroup_name: " + group_name.ToString() +
            "\nend_effector: " + end_effector.ToString() +
            "\npossible_grasps: " + System.String.Join(", ", possible_grasps.ToList()) +
            "\nsupport_surface_name: " + support_surface_name.ToString() +
            "\nallow_gripper_support_collision: " + allow_gripper_support_collision.ToString() +
            "\nattached_object_touch_links: " + System.String.Join(", ", attached_object_touch_links.ToList()) +
            "\nminimize_object_distance: " + minimize_object_distance.ToString() +
            "\npath_constraints: " + path_constraints.ToString() +
            "\nplanner_id: " + planner_id.ToString() +
            "\nallowed_touch_objects: " + System.String.Join(", ", allowed_touch_objects.ToList()) +
            "\nallowed_planning_time: " + allowed_planning_time.ToString() +
            "\nplanning_options: " + planning_options.ToString();
        }
    }
}
