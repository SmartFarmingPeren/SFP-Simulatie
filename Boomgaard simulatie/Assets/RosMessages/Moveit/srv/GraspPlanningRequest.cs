//Do not edit! This file was generated by Unity-ROS MessageGeneration.
using System;
using System.Linq;
using System.Collections.Generic;
using System.Text;
using Unity.Robotics.ROSTCPConnector.MessageGeneration;

namespace RosMessageTypes.Moveit
{
    public class GraspPlanningRequest : Message
    {
        public const string RosMessageName = "moveit_msgs/GraspPlanning";

        //  Requests that grasp planning be performed for the target object
        //  returns a list of candidate grasps to be tested and executed
        //  the planning group used
        public string group_name;
        //  the object to be grasped
        public CollisionObject target;
        //  the names of the relevant support surfaces (e.g. tables) in the collision map
        //  can be left empty if no names are available
        public string[] support_surfaces;
        //  an optional list of grasps to be evaluated by the planner
        public Grasp[] candidate_grasps;
        //  an optional list of obstacles that we have semantic information about
        //  and that can be moved in the course of grasping
        public CollisionObject[] movable_obstacles;

        public GraspPlanningRequest()
        {
            this.group_name = "";
            this.target = new CollisionObject();
            this.support_surfaces = new string[0];
            this.candidate_grasps = new Grasp[0];
            this.movable_obstacles = new CollisionObject[0];
        }

        public GraspPlanningRequest(string group_name, CollisionObject target, string[] support_surfaces, Grasp[] candidate_grasps, CollisionObject[] movable_obstacles)
        {
            this.group_name = group_name;
            this.target = target;
            this.support_surfaces = support_surfaces;
            this.candidate_grasps = candidate_grasps;
            this.movable_obstacles = movable_obstacles;
        }
        public override List<byte[]> SerializationStatements()
        {
            var listOfSerializations = new List<byte[]>();
            listOfSerializations.Add(SerializeString(this.group_name));
            listOfSerializations.AddRange(target.SerializationStatements());
            
            listOfSerializations.Add(BitConverter.GetBytes(support_surfaces.Length));
            foreach(var entry in support_surfaces)
                listOfSerializations.Add(SerializeString(entry));
            
            listOfSerializations.Add(BitConverter.GetBytes(candidate_grasps.Length));
            foreach(var entry in candidate_grasps)
                listOfSerializations.Add(entry.Serialize());
            
            listOfSerializations.Add(BitConverter.GetBytes(movable_obstacles.Length));
            foreach(var entry in movable_obstacles)
                listOfSerializations.Add(entry.Serialize());

            return listOfSerializations;
        }

        public override int Deserialize(byte[] data, int offset)
        {
            var group_nameStringBytesLength = DeserializeLength(data, offset);
            offset += 4;
            this.group_name = DeserializeString(data, offset, group_nameStringBytesLength);
            offset += group_nameStringBytesLength;
            offset = this.target.Deserialize(data, offset);
            
            var support_surfacesArrayLength = DeserializeLength(data, offset);
            offset += 4;
            this.support_surfaces= new string[support_surfacesArrayLength];
            for(var i = 0; i < support_surfacesArrayLength; i++)
            {
                var support_surfacesStringBytesLength = DeserializeLength(data, offset);
                offset += 4;
                this.support_surfaces[i] = DeserializeString(data, offset, support_surfacesStringBytesLength);
                offset += support_surfacesStringBytesLength;
            }
            
            var candidate_graspsArrayLength = DeserializeLength(data, offset);
            offset += 4;
            this.candidate_grasps= new Grasp[candidate_graspsArrayLength];
            for(var i = 0; i < candidate_graspsArrayLength; i++)
            {
                this.candidate_grasps[i] = new Grasp();
                offset = this.candidate_grasps[i].Deserialize(data, offset);
            }
            
            var movable_obstaclesArrayLength = DeserializeLength(data, offset);
            offset += 4;
            this.movable_obstacles= new CollisionObject[movable_obstaclesArrayLength];
            for(var i = 0; i < movable_obstaclesArrayLength; i++)
            {
                this.movable_obstacles[i] = new CollisionObject();
                offset = this.movable_obstacles[i].Deserialize(data, offset);
            }

            return offset;
        }

        public override string ToString()
        {
            return "GraspPlanningRequest: " +
            "\ngroup_name: " + group_name.ToString() +
            "\ntarget: " + target.ToString() +
            "\nsupport_surfaces: " + System.String.Join(", ", support_surfaces.ToList()) +
            "\ncandidate_grasps: " + System.String.Join(", ", candidate_grasps.ToList()) +
            "\nmovable_obstacles: " + System.String.Join(", ", movable_obstacles.ToList());
        }
    }
}
